<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Necromancer Roguelike - Mobile First</title>
    <style>
        * { box-sizing: border-box; }
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%; background-color: #000;
            color: #e0e0e0; font-family: 'Courier New', Courier, monospace; overflow: hidden;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
        }
        #game-container {
            position: relative; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
        }
        canvas { display: block; background-color: #0d0d0d; cursor: none; transition: background-color 1s; max-width: 100%; max-height: 100%; }
        
        /* UI OVERLAY */
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; text-shadow: 2px 2px 4px #000; padding: 10px; }
        .top-ui-left, .top-ui-right { position: absolute; top: 10px; font-size: calc(12px + 1vw); }
        .top-ui-left { left: 10px; }
        .top-ui-right { right: 10px; text-align: right;}
        #player-health-bar { width: clamp(150px, 30vw, 250px); height: 20px; background-color: #444; border: 1px solid #777; margin-top: 5px; }
        #player-health { width: 100%; height: 100%; background-color: #b30000; transition: width 0.2s; }

        /* XP & COMBO */
        #gameplay-feedback-ui { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 40%; max-width: 300px;}
        #player-xp-bar { width: 100%; height: 12px; background-color: rgba(0,0,0,0.5); border: 1px solid #8e44ad; }
        #player-xp { height: 100%; background-color: #f1c40f; transition: width 0.2s; }
        #player-xp.pulsing { animation: pulse 1s infinite; }
        #combo-meter { margin-top: 5px; font-size: 24px; font-weight: bold; text-align: center; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7); } 70% { box-shadow: 0 0 5px 10px rgba(241, 196, 15, 0); } 100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); } }

        #boss-ui { display: none; position: absolute; top: calc(30px + 3vw); left: 50%; transform: translateX(-50%); width: 70%; text-align: center; }
        #boss-name { font-size: calc(16px + 1.5vw); color: #e74c3c; text-shadow: 0 0 5px #c0392b; }
        #boss-health-bar { width: 100%; height: 25px; background-color: #444; border: 2px solid #e74c3c; margin-top: 5px; }
        #boss-health { width: 100%; height: 100%; background: linear-gradient(90deg, #c0392b, #ff4d4d); transition: width 0.3s; }

        .screen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; padding: 15px; }
        h1 { font-size: clamp(2.5em, 10vw, 4em); color: #8e44ad; text-shadow: 0 0 10px #8e44ad; margin-bottom: 10px; }
        p { font-size: clamp(1em, 4vw, 1.3em); margin: 10px; }
        button { padding: 15px 30px; font-size: clamp(1.2em, 5vw, 1.8em); background-color: #8e44ad; color: white; border: 2px solid #c07df7; cursor: pointer; border-radius: 5px; margin: 10px; }
        
        #card-selection-screen, #tome-screen { pointer-events: all; }
        #card-options { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 20px; width:100%;}
        .card { width: 160px; height: 220px; background-color: #2c3e50; border: 3px solid #7f8c8d; border-radius: 10px; padding: 10px; display: flex; flex-direction: column; align-items: center; text-align: center; }
        .card h3 { color: #e67e22; margin-top: 0; font-size: 1.1em; }
        .card p { font-size: 0.85em; flex-grow: 1; }

        #tome-upgrades { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; max-height: 50vh; overflow-y: auto; padding: 10px; width: 90%; max-width: 500px; }
        .upgrade-item { background-color: #2c3e50; border: 2px solid #7f8c8d; padding: 10px; border-radius: 5px; display: flex; justify-content: space-between; align-items: center; }
        .upgrade-info h4 { margin: 0 0 5px 0; color: #e67e22; font-size: 1em; } .upgrade-info p { margin: 0; font-size: 0.8em; }
        .upgrade-item button { font-size: 0.9em; padding: 10px 15px; } .upgrade-item button:disabled { background-color: #7f8c8d; cursor: not-allowed; }

        /* CONTROLES MOBILE REDESENHADOS */
        #mobile-controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; display: block; }
        .joystick-base {
            position: absolute;
            width: clamp(120px, 30vw, 200px); height: clamp(120px, 30vw, 200px);
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            pointer-events: all;
            display: flex; justify-content: center; align-items: center;
        }
        .joystick-stick {
            width: 50%; height: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
        }
        #move-joystick-base { left: 20px; bottom: 20px; }
        #aim-joystick-base { right: 20px; bottom: 20px; }

        #revive-button-container {
            position: absolute; right: calc(clamp(120px, 30vw, 200px) + 30px); bottom: 40px;
            pointer-events: all;
        }
        #revive-button {
            width: clamp(70px, 18vw, 100px); height: clamp(70px, 18vw, 100px);
            background-color: rgba(68, 173, 90, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center; color: white;
            font-size: 14px; text-align: center;
        }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-overlay">
            <div class="top-ui-left">
                <span>VIDA:</span><div id="player-health-bar"><div id="player-health"></div></div>
                <div id="minion-counter">LACAIOS: 0/5</div>
            </div>
             <div class="top-ui-right">
                <div id="room-counter">SALA: 1</div>
                <div id="enemy-counter">INIMIGOS: 0</div>
            </div>
            <div id="boss-ui"><div id="boss-name"></div><div id="boss-health-bar"><div id="boss-health"></div></div></div>
            <div id="gameplay-feedback-ui"><div id="player-xp-bar"><div id="player-xp"></div></div><div id="combo-meter"></div></div>
        </div>
        
        <div id="mobile-controls">
            <div id="move-joystick-base" class="joystick-base"><div id="move-joystick-stick" class="joystick-stick"></div></div>
            <div id="aim-joystick-base" class="joystick-base"><div id="aim-joystick-stick" class="joystick-stick"></div></div>
            <div id="revive-button-container"><div id="revive-button">REVIVER</div></div>
        </div>

        <div id="start-screen" class="screen-overlay">
            <h1>Necromancer's Rise</h1>
            <p>Comande com o joystick esquerdo. Mire e atire com o direito.</p>
            <button id="start-button">Iniciar Jogo</button>
        </div>
        <div id="game-over-screen" class="screen-overlay" style="display: none;">
            <h1 id="game-over-title">Fim de Jogo</h1>
            <p id="final-score">Você chegou até a sala 1.</p>
            <p id="last-boss-defeated">Último chefe derrotado: Nenhum</p>
            <p id="ectoplasma-earned">Ectoplasma coletado: 0</p>
            <div><button id="restart-button">Tentar Novamente</button><button id="tome-button">Abrir Tomo</button></div>
        </div>
        <div id="card-selection-screen" class="screen-overlay" style="display: none;"><h1>Escolha um Aprimoramento</h1><p>Seu poder cresce a cada sala conquistada.</p><div id="card-options"></div></div>
        <div id="tome-screen" class="screen-overlay" style="display: none;"><h1>Tomo dos Condenados</h1><p>Use seu Ectoplasma para obter poder eterno.</p><p id="tome-ectoplasma-total">Ectoplasma Total: 0</p><div id="tome-upgrades"></div><button id="close-tome-button">Fechar</button></div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const getUI = id => document.getElementById(id);
        const ui = {
            health: getUI('player-health'), room: getUI('room-counter'), minions: getUI('minion-counter'), enemyCounter: getUI('enemy-counter'),
            startScreen: getUI('start-screen'), gameOverScreen: getUI('game-over-screen'), cardScreen: getUI('card-selection-screen'), cardOptions: getUI('card-options'),
            startButton: getUI('start-button'), restartButton: getUI('restart-button'), finalScore: getUI('final-score'), lastBossDefeated: getUI('last-boss-defeated'),
            xpBar: getUI('player-xp-bar'), xpFill: getUI('player-xp'), comboMeter: getUI('combo-meter'), ectoplasmaEarned: getUI('ectoplasma-earned'),
            tomeScreen: getUI('tome-screen'), tomeButton: getUI('tome-button'), closeTomeButton: getUI('close-tome-button'),
            tomeEctoplasmaTotal: getUI('tome-ectoplasma-total'), tomeUpgradesContainer: getUI('tome-upgrades'),
            bossUi: getUI('boss-ui'), bossName: getUI('boss-name'), bossHealth: getUI('boss-health')
        };
        
        let gameState, currentRoom, player, enemies, projectiles, corpses, minions, portal, boss;
        let essenceOrbs, floatingTexts, specialEffects, screenShake, combo, comboTimer, obstacles, metaProgress, isBossRoom;
        let lastBossDefeatedName = "Nenhum";
        let controls = {
            move: { x: 0, y: 0, active: false },
            aim: { x: 0, y: 0, active: false },
            revive: false,
        };

        const biomes = [{ name: "Cripta", bgColor: '#0d0d0d', bodyColor: '#1a1a1a', obstacleColor: '#3d3d3d', obstacleDensity: 0.2 },{ name: "Poços de Sangue", bgColor: '#2a0000', bodyColor: '#1e0000', obstacleColor: '#6b2737', obstacleDensity: 0.3 },{ name: "Reino das Sombras", bgColor: '#0d031a', bodyColor: '#100522', obstacleColor: '#4b0082', obstacleDensity: 0.1 }];
        function loadGameData() { const savedData = JSON.parse(localStorage.getItem('necromancerRiseProgress')); if (savedData) { metaProgress = savedData; } else { metaProgress = { ectoplasma: 0, lastBoss: "Nenhum", upgrades: { baseHealth: 0, baseDamage: 0, minionPower: 0, critChance: 0, essenceHeal: 0 } }; } lastBossDefeatedName = metaProgress.lastBoss || "Nenhum";}
        function saveGameData() { metaProgress.lastBoss = lastBossDefeatedName; localStorage.setItem('necromancerRiseProgress', JSON.stringify(metaProgress)); }

        // --- CLASSES (COM FLESH AMALGAM CORRIGIDO) ---
        class Entity { constructor(x, y, size, color) { this.x = x; this.y = y; this.size = size; this.color = color; this.isDead = false; this.hitTimer = 0; } draw() { if (this.isDead) return; ctx.fillStyle = this.hitTimer > 0 ? '#ffffff' : this.color; ctx.fillRect(this.x, this.y, this.size, this.size); } update() { if(this.hitTimer > 0) this.hitTimer--; } clampToBounds() { this.x = Math.max(0, Math.min(canvas.width - this.size, this.x)); this.y = Math.max(0, Math.min(canvas.height - this.size, this.y)); } }
        class Battler extends Entity { constructor(x, y, size, color, health, speed, damage) { super(x, y, size, color); this.maxHealth = health; this.health = health; this.speed = speed; this.baseSpeed = speed; this.damage = damage; this.target = null; this.slowTimer = 0; } takeDamage(amount, isCrit = false) { if (this.isDead) return; this.health -= amount; this.hitTimer = 5; floatingTexts.push(new FloatingText(this.x + this.size/2, this.y, Math.round(amount), isCrit ? '#ffd700' : '#ffffff', isCrit)); if (this.health <= 0) { this.health = 0; this.isDead = true; } } drawHealthBar() { if (this.isDead || this instanceof Player) return; ctx.fillStyle = '#c0392b'; ctx.fillRect(this.x, this.y - 10, this.size, 5); ctx.fillStyle = '#27ae60'; ctx.fillRect(this.x, this.y - 10, this.size * (this.health / this.maxHealth), 5); } findTarget(potentialTargets) { let closestDist = this.aggroRadius || Infinity; this.target = null; for (const t of potentialTargets) { if (t.isDead) continue; const dist = Math.hypot(this.x - t.x, this.y - t.y); if (dist < closestDist) { closestDist = dist; this.target = t; } } } move(newX, newY) { this.x = newX; this.y = newY; this.clampToBounds(); } moveToTarget() { const finalSpeed = this.slowTimer > 0 ? this.speed * 0.5 : this.speed; const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); this.move(this.x + Math.cos(angle) * finalSpeed, this.y + Math.sin(angle) * finalSpeed); } moveFromTarget() { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); this.move(this.x - Math.cos(angle) * this.speed, this.y - Math.sin(angle) * this.speed); } update(){ super.update(); if(this.slowTimer > 0) this.slowTimer--; } }
        class Projectile extends Entity { constructor(x, y, radius, color, speed, angle, damage, isCrit = false, owner='none') { super(x, y, radius * 2, color); this.radius = radius; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.damage = damage; this.isCrit = isCrit; this.owner = owner; } update() { this.x += this.vx; this.y += this.vy; } draw() { if(this.isDead) return; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill(); } }
        class PlayerProjectile extends Projectile { constructor(x, y, angle, damage, isCrit) { const radius = isCrit ? 8 : 5; const color = isCrit ? '#f1c40f' : '#9b59b6'; super(x, y, radius, color, 8, angle, damage, isCrit, 'player'); } }
        class EnemyProjectile extends Projectile { constructor(x, y, angle, damage, color = '#f39c12', speed = 6) { super(x, y, 6, color, speed, angle, damage, false, 'enemy'); this.radius = color === '#9b59b6' ? 9 : 6; } }
        class MinionProjectile extends Projectile { constructor(x, y, angle, damage, onHitEffect = null) { super(x, y, 4, '#ecf0f1', 7, angle, damage, false, 'minion'); this.onHitEffect = onHitEffect; } }
        class Player extends Battler { constructor(x, y) { const upgrades = metaProgress.upgrades; super(x, y, 30, '#8e44ad', 100 + (upgrades.baseHealth * 10), 4, 0); this.maxMinions = 5; this.minionPower = 1.0 + (upgrades.minionPower * 0.1); this.projectileDamage = 25 + (upgrades.baseDamage * 3); this.critChance = 0.1 + (upgrades.critChance * 0.02); this.essenceHeal = 2 + upgrades.essenceHeal; this.critMultiplier = 2.0; this.shootCooldown = 0; this.reviveCooldown = 0; this.level = 1; this.xp = 0; this.xpToNextLevel = 100; } gainXP(amount) { const boostedAmount = Math.ceil(amount * (1 + (combo - 1) * 0.1)); this.xp += boostedAmount; metaProgress.ectoplasma++; while (this.xp >= this.xpToNextLevel) { this.xp -= this.xpToNextLevel; this.levelUp(); } } levelUp() { this.level++; this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5); this.maxHealth += 10; this.health = this.maxHealth; this.projectileDamage += 2; specialEffects.push(new LevelUpEffect(this.x + this.size/2, this.y + this.size/2)); screenShake = 15; } takeDamage(amount) { if (this.isDead) return; this.hitTimer = 5; floatingTexts.push(new FloatingText(this.x + this.size/2, this.y, Math.round(amount), '#ff4d4d')); this.health -= amount; if (this.health <= 0) { this.health = 0; this.isDead = true; gameState = 'gameOver'; handleGameOver(); } } draw() { if(this.isDead) return; super.draw(); } 
            update() { super.update(); this.x += controls.move.x * this.speed; this.y += controls.move.y * this.speed; this.clampToBounds(); if (this.shootCooldown > 0) this.shootCooldown--; if (this.reviveCooldown > 0) this.reviveCooldown--; if (controls.aim.active && this.shootCooldown === 0) { const angle = Math.atan2(controls.aim.y, controls.aim.x); const isCrit = Math.random() < this.critChance; const finalDamage = isCrit ? this.projectileDamage * this.critMultiplier : this.projectileDamage; projectiles.push(new PlayerProjectile(this.x + this.size / 2, this.y + this.size / 2, angle, finalDamage, isCrit)); this.shootCooldown = 15; } if (controls.revive && this.reviveCooldown === 0 && minions.length < this.maxMinions) { this.reviveClosestCorpse(); controls.revive = false; } }
            reviveClosestCorpse() { let closestCorpse = null; let minDist = 150; for(const corpse of corpses) { const dist = Math.hypot(this.x - corpse.x, this.y - corpse.y); if(dist < minDist) { minDist = dist; closestCorpse = corpse; } } if(closestCorpse) { const index = corpses.indexOf(closestCorpse); this.createMinionFromCorpse(closestCorpse, index); } }
            createMinionFromCorpse(corpse, index) { let minionToAdd = null; switch (corpse.type) { case 'ranged': minionToAdd = new RangedMinion(corpse.x, corpse.y); break; case 'cultist': minionToAdd = new WailingSpiritMinion(corpse.x, corpse.y); break; case 'shadowmancer': minionToAdd = new WraithMinion(corpse.x, corpse.y); break; default: minionToAdd = new MeleeMinion(corpse.x, corpse.y, corpse.type); break; } minions.push(minionToAdd); corpses.splice(index, 1); this.reviveCooldown = 30; updateMinionFormations(); }
        }
        class MeleeMinion extends Battler { constructor(x, y, revivedType) { const h = revivedType === 'brute' ? 1.5 : 1.0, d = revivedType === 'brute' ? 1.2 : 1.0; super(x, y, 20, '#2ecc71', (50 * player.minionPower) * h, 3.5, (10 * player.minionPower) * d); this.aggroRadius = 350; this.formationOffset = { x: 0, y: 0 }; } draw() { if(this.isDead) return; super.draw(); this.drawHealthBar(); } update() { super.update(); this.findTarget(enemies.concat(boss ? [boss] : [])); if (this.target) this.moveToTarget(); else this.returnToFormation(); } returnToFormation() { const targetX = player.x + this.formationOffset.x, targetY = player.y + this.formationOffset.y; const dist = Math.hypot(targetX - this.x, targetY - this.y); if (dist > 5) { const angle = Math.atan2(targetY - this.y, targetX - this.x); const moveSpeed = this.speed * (dist > 50 ? 2 : 1); this.move(this.x + Math.cos(angle) * moveSpeed, this.y + Math.sin(angle) * moveSpeed); } } }
        class RangedMinion extends MeleeMinion { constructor(x, y) { super(x, y); Object.assign(this, { color: '#1abc9c', maxHealth: 40 * player.minionPower, health: 40 * player.minionPower, damage: 8 * player.minionPower, aggroRadius: 450, optimalDistance: 250, shootCooldown: 0, shootRate: 90, }); } draw() { if(this.isDead) return; super.draw(); this.drawHealthBar();} update() { if(this.shootCooldown > 0) this.shootCooldown--; this.findTarget(enemies.concat(boss ? [boss] : [])); if (this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if (dist > this.optimalDistance) this.moveToTarget(); else if (dist < this.optimalDistance - 50) this.moveFromTarget(); else if (this.shootCooldown === 0) { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); projectiles.push(new MinionProjectile(this.x + this.size/2, this.y + this.size/2, angle, this.damage)); this.shootCooldown = this.shootRate; } } else this.returnToFormation(); } }
        class WailingSpiritMinion extends RangedMinion { constructor(x,y) { super(x,y); Object.assign(this, { color: '#bdc3c7', shootRate: 120 }); } update() { if(this.shootCooldown > 0) this.shootCooldown--; this.findTarget(enemies.concat(boss ? [boss] : [])); if (this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if (dist > this.optimalDistance) this.moveToTarget(); else if (dist < this.optimalDistance - 50) this.moveFromTarget(); else if (this.shootCooldown === 0) { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); projectiles.push(new MinionProjectile(this.x + this.size/2, this.y + this.size/2, angle, this.damage, (target) => { target.slowTimer = 120; })); this.shootCooldown = this.shootRate; } } else this.returnToFormation(); } }
        class WraithMinion extends MeleeMinion { constructor(x,y) { super(x,y); Object.assign(this, { color: '#5e3370', speed: 4.5, damage: 20 * player.minionPower, dashCooldown: 0, dashRate: 180, aggroRadius: 500 }); } draw() { if(this.isDead)return; ctx.globalAlpha=this.dashCooldown > this.dashRate - 30 ? 0.5 : 1.0; super.draw(); ctx.globalAlpha=1.0;} update() { super.update(); this.findTarget(enemies.concat(boss ? [boss] : [])); if(this.dashCooldown > 0) this.dashCooldown--; if (this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if(dist > 100 && this.dashCooldown <= 0) { this.x = this.target.x; this.y = this.target.y; this.dashCooldown = this.dashRate; screenShake=5; } else { this.moveToTarget(); } } else { this.returnToFormation(); } } }

        // --- ENEMY CLASSES ---
        class MeleeEnemy extends Battler { constructor(x, y, room) { super(x, y, 25, '#e74c3c', 25 + room * 20, 1.2 + room * 0.2, 8 + room * 2.5); this.baseXp = 10; this.type = 'melee'; this.lungeCooldown = 180; this.lungeDuration = 0; this.frenzyTimer = 0; } draw() { if(this.isDead) return; this.color = this.frenzyTimer > 0 ? '#ff7f50' : '#e74c3c'; super.draw(); this.drawHealthBar(); } update() { super.update(); this.findTarget([player, ...minions]); if(this.frenzyTimer > 0) this.frenzyTimer--; if (this.lungeCooldown > 0) this.lungeCooldown--; if (this.lungeDuration > 0) { this.lungeDuration--; if(this.lungeDuration === 0) { this.speed = this.baseSpeed; this.frenzyTimer = 120; this.speed *= 1.5; } } if(this.frenzyTimer === 1) this.speed = this.baseSpeed; if(this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if(dist < 180 && this.lungeCooldown === 0) { this.speed = this.baseSpeed * 3; this.lungeDuration = 30; this.lungeCooldown = 240; } this.moveToTarget(); } } }
        class RangedEnemy extends Battler { constructor(x, y, room) { super(x, y, 28, '#3498db', 20 + room * 15, 0.9 + room * 0.15, 10 + room * 3); this.baseXp = 10; this.type = 'ranged'; this.optimalDistance = 350; this.shootCooldown = Math.random() * 120 + 60; this.shootRate = 180; this.chargedShotCooldown = 480; } draw() { if (this.isDead) return; let angle = this.target ? Math.atan2(this.target.y - this.y, this.target.x - this.x) : 0; ctx.save(); ctx.translate(this.x + this.size / 2, this.y + this.size / 2); ctx.rotate(angle); ctx.fillStyle = this.hitTimer > 0 ? '#ffffff' : (this.chargedShotCooldown < 120 ? '#c0392b' : this.color); ctx.beginPath(); ctx.moveTo(this.size / 2, 0); ctx.lineTo(-this.size / 2, -this.size / 3); ctx.lineTo(-this.size / 2, this.size / 3); ctx.closePath(); ctx.fill(); ctx.restore(); this.drawHealthBar(); } update() { super.update(); if(this.shootCooldown > 0) this.shootCooldown--; if(this.chargedShotCooldown > 0) this.chargedShotCooldown--; this.findTarget([player, ...minions]); if(this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if(dist > this.optimalDistance + 50) this.moveToTarget(); else if (dist < this.optimalDistance) this.moveFromTarget(); else { if(this.chargedShotCooldown <= 0) { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); projectiles.push(new EnemyProjectile(this.x+this.size/2, this.y+this.size/2, angle, this.damage * 2.5, '#9b59b6', 4)); this.chargedShotCooldown = 500; this.shootCooldown = 120; } else if(this.shootCooldown <= 0) { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); projectiles.push(new EnemyProjectile(this.x+this.size/2, this.y+this.size/2, angle, this.damage)); this.shootCooldown = this.shootRate; } } } } }
        class BruteEnemy extends Battler { constructor(x, y, room) { super(x, y, 40, '#6c7a89', 100 + room * 30, 0.8 + room * 0.08, 12 + room * 4); this.baseXp = 30; this.type = 'brute'; this.stompRadius = 120; this.stompCooldown = 300; this.stompCharge = 0; this.enraged = false; } draw() { if (this.isDead) return; const baseColor = this.enraged ? '#c0392b' : this.color; ctx.beginPath(); ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2); ctx.fillStyle = this.hitTimer > 0 ? '#ffffff' : (this.stompCharge > 0 ? '#f1c40f' : baseColor); ctx.fill(); if(this.stompCharge > 0) { const chargeProgress = this.stompCharge / 60; ctx.strokeStyle = `rgba(241, 196, 15, ${0.2 + chargeProgress * 0.6})`; ctx.lineWidth = 2 + chargeProgress * 3; ctx.beginPath(); ctx.arc(this.x + this.size/2, this.y + this.size/2, this.stompRadius * (1 - chargeProgress), 0, Math.PI * 2); ctx.stroke(); } this.drawHealthBar(); } update() { super.update(); if (!this.enraged && this.health / this.maxHealth < 0.4) { this.enraged = true; this.speed *= 1.5; this.stompCooldown = Math.min(this.stompCooldown, 150); } if (this.stompCooldown > 0 && this.stompCharge === 0) this.stompCooldown--; if (this.stompCharge > 0) { this.stompCharge--; if (this.stompCharge === 1) { [player, ...minions].forEach(unit => { if(!unit.isDead && Math.hypot(this.x + this.size/2 - (unit.x + unit.size/2), this.y + this.size/2 - (unit.y + unit.size/2)) < this.stompRadius) unit.takeDamage(this.damage * 2); }); screenShake = 20; } if(this.stompCharge === 0) this.stompCooldown = this.enraged ? 180 : 300; return; } this.findTarget([player, ...minions]); if(this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if(dist < this.size * 1.5 && this.stompCooldown === 0) { this.stompCharge = 60; } else { this.moveToTarget(); } } } }
        class CultistEnemy extends Battler { constructor(x,y,room) { super(x, y, 30, '#556b2f', 50 + room * 10, 0.5 + room*0.05, 0); this.baseXp=15; this.type = 'cultist'; this.spawnCooldown = 0; this.spawnRate = 360; this.aggroRadius = 600;} draw() { if(this.isDead) return; super.draw(); this.drawHealthBar(); } update() { super.update(); if(this.spawnCooldown > 0) this.spawnCooldown--; this.findTarget([player]); if(this.target) { if(this.spawnCooldown <= 0) { enemies.push(new ShadeEnemy(this.x, this.y)); this.spawnCooldown = this.spawnRate;} this.moveFromTarget(); } } }
        class ShadeEnemy extends Battler { constructor(x,y) { super(x, y, 15, '#483d8b', 10, 3, 5); this.type='shade'; this.life=300; this.aggroRadius=800; } takeDamage(a){super.takeDamage(a);} draw() { if(this.isDead) return; ctx.globalAlpha = this.life/300; super.draw(); ctx.globalAlpha = 1.0; } update() { this.life--; if(this.life <= 0) this.isDead = true; super.update(); this.findTarget([player, ...minions]); if(this.target) this.moveToTarget(); } }
        class ShadowmancerEnemy extends Battler { constructor(x, y, room) { super(x, y, 28, '#4b0082', 40 + room * 15, 1, 15 + room * 3); this.baseXp = 25; this.type = 'shadowmancer'; this.teleportCooldown = 240; this.shootCooldown = 90; } draw() {if(this.isDead)return; ctx.globalAlpha=this.teleportCooldown < 30 ? 0.5:1; super.draw(); ctx.globalAlpha=1; this.drawHealthBar(); } update() { super.update(); this.findTarget([player, ...minions]); if(this.teleportCooldown > 0) this.teleportCooldown--; else if(this.target) { this.x = this.target.x + (Math.random() - 0.5) * 300; this.y = this.target.y + (Math.random() - 0.5) * 300; this.clampToBounds(); this.teleportCooldown = 300; screenShake=8; } if(this.shootCooldown > 0) this.shootCooldown--; else if(this.target) { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); projectiles.push(new EnemyProjectile(this.x + this.size/2, this.y + this.size/2, angle, this.damage)); this.shootCooldown=120;}}}
        
        // --- BOSS CLASSES ---
        class LichKingBoss extends Battler { constructor(x,y,room) { super(x, y, 80, '#e74c3c', 1000 + room * 250, 0.8, 25 + room*5); this.baseXp = 1000; this.phase = 1; this.actionCooldown = 180; ui.bossName.textContent = 'Lich Overlord'; this.bossName = 'Lich Overlord';} draw() {if(this.isDead) return; ctx.fillStyle= this.phase === 2 ? '#ff4d4d' : '#e74c3c'; ctx.fillRect(this.x,this.y,this.size,this.size); } update() { super.update(); this.findTarget([player, ...minions]); if(this.target) this.moveToTarget(); if(this.phase === 1 && this.health / this.maxHealth < 0.5) {this.phase = 2; this.actionCooldown=0;} this.actionCooldown--; if(this.actionCooldown <= 0) { if(this.phase === 1) { this.summonHelp(2, ['melee', 'ranged']); this.actionCooldown=300;} else { this.summonHelp(1, ['brute', 'cultist']); specialEffects.push(new SoulBeamEffect(this)); this.actionCooldown=400;} } }
            summonHelp(count, types) { for(let i=0; i<count; i++) {const x=this.x+(Math.random()-0.5)*200; const y=this.y+(Math.random()-0.5)*200; const type = types[Math.floor(Math.random()*types.length)]; if(type==='brute') {enemies.push(new BruteEnemy(x,y,currentRoom));} else if(type==='ranged') {enemies.push(new RangedEnemy(x,y,currentRoom));} else if(type==='cultist') {enemies.push(new CultistEnemy(x,y,currentRoom));} else {enemies.push(new MeleeEnemy(x,y,currentRoom));} } }
        }
        class FleshAmalgamBoss extends Battler { constructor(x,y,room) { super(x,y,100,'#8b4513', 1500+room*300, 0.5, 30+room*6); this.baseXp = 1000; this.actionCooldown = 300; this.isPulling = false; ui.bossName.textContent = 'The Flesh Amalgam'; this.bossName = 'The Flesh Amalgam'; } draw() {if(this.isDead) return; ctx.beginPath(); ctx.arc(this.x+this.size/2, this.y+this.size/2, this.size/2, 0, Math.PI*2); ctx.fillStyle= this.isPulling ? '#d2691e' : this.color; ctx.fill();} 
            update() { super.update(); this.findTarget([player, ...minions]); if(this.target && !this.isPulling) this.moveToTarget(); specialEffects.push(new SlimeTrail(this.x, this.y, this.size)); this.actionCooldown--; if(this.actionCooldown <= 0) { this.isPulling = true; [player, ...minions].forEach(t => { const angle = Math.atan2(this.y - t.y, this.x - t.x); t.x += Math.cos(angle) * 2; t.y += Math.sin(angle) * 2;}); if(this.actionCooldown < -60) { this.isPulling = false; this.actionCooldown = 400; screenShake=15; specialEffects.push(new ExplosionEffect(this.x+this.size/2, this.y+this.size/2, this.size*1.5, this.damage*3)); } } } 
        }
        class EyeOfChaosBoss extends Battler { constructor(x,y,room) {super(x,y,70, '#4b0082', 800+room*200, 0, 20+room*4); this.baseXp=1000; this.actionCooldown = 180; this.angle=0; this.x = canvas.width/2 - this.size/2; this.y = 150; ui.bossName.textContent = 'The Eye of Chaos'; this.bossName = 'The Eye of Chaos'; } draw() { if(this.isDead) return; ctx.beginPath(); ctx.arc(this.x+this.size/2, this.y+this.size/2, this.size/2, 0, Math.PI*2); ctx.fillStyle = this.color; ctx.fill(); ctx.save(); ctx.translate(this.x+this.size/2, this.y+this.size/2); ctx.rotate(this.angle * 2); ctx.fillStyle='red'; ctx.fillRect(-this.size/4, -5, this.size/2, 10); ctx.fillRect(-5, -this.size/4, 10, this.size/2); ctx.restore(); } update() {super.update(); this.actionCooldown--; this.angle+=0.01; if(this.actionCooldown <= 0) { const choice = Math.random(); if(choice < 0.6) { for(let i=0; i<8; i++) { projectiles.push(new EnemyProjectile(this.x+this.size/2, this.y+this.size/2, this.angle + i*Math.PI/4, this.damage));}} else { const targets = minions.filter(m => !m.isDead); if(targets.length>0) {const target=targets[Math.floor(Math.random()*targets.length)]; projectiles.push(new EnemyProjectile(this.x+this.size/2, this.y+this.size/2, Math.atan2(target.y-this.y, target.x-this.x), this.damage*1.5, '#f39c12', 4));}} this.actionCooldown=90;}}}
        
        // --- EFFECTS AND MAP ---
        class Obstacle { constructor(x,y,w,h,color) {this.x=x; this.y=y; this.w=w; this.h=h; this.color=color;} draw(){ctx.fillStyle=this.color; ctx.fillRect(this.x,this.y,this.w,this.h);} }
        class Corpse { constructor(x,y,size,type) { this.x = x; this.y = y; this.size = size; this.type = type; this.color = '#7f8c8d'; } draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size / 2.2, 0, Math.PI * 2); ctx.fill(); } }
        class Portal { constructor(x,y) { this.x = x; this.y = y; this.size = 50; this.color = '#3498db'; this.angle = 0; } update() { this.angle += 0.02; } draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = this.color; ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); ctx.strokeStyle = '#ecf0f1'; ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size); ctx.restore(); } }
        class FloatingText { constructor(x, y, text, color, isCrit = false) { this.x = x; this.y = y; this.text = text; this.color = color; this.duration = 60; this.vy = -1.5; this.fontSize = isCrit ? 24 : 18; } update() { this.duration--; this.y += this.vy; this.vy *= 0.98; } draw() { ctx.save(); ctx.globalAlpha = Math.max(0, this.duration / 60); ctx.fillStyle = this.color; ctx.font = `bold ${this.fontSize}px 'Courier New'`; ctx.textAlign = 'center'; ctx.shadowColor = 'black'; ctx.shadowBlur = 4; ctx.fillText(this.text, this.x, this.y); ctx.restore(); } }
        class EssenceOrb { constructor(x,y, xpValue) { this.x = x; this.y = y; this.size = 12; this.color = '#bf34db'; this.collectionRadius = 150; this.speed = 3; this.xpValue = xpValue; } update() { const distToPlayer = Math.hypot(this.x - (player.x + player.size/2), this.y - (player.y + player.size/2)); if (distToPlayer < this.collectionRadius) { const angle = Math.atan2((player.y + player.size/2) - this.y, (player.x + player.size/2) - this.x); this.x += Math.cos(angle) * this.speed; this.y += Math.sin(angle) * this.speed; this.speed += 0.3; } } draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.stroke(); } }
        class LevelUpEffect { constructor(x, y) { this.x = x; this.y = y; this.radius = 0; this.maxRadius = 300; this.duration = 40; this.life = this.duration; } update() { this.life--; this.radius = this.maxRadius * (1 - this.life / this.duration); } draw() { ctx.save(); ctx.globalAlpha = Math.max(0, this.life / this.duration); ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); } }
        class SoulBeamEffect { constructor(owner) { this.owner = owner; this.target = player; this.life = 120; this.width=0;} update() { this.life--; this.width = 40 * (1 - Math.abs(this.life - 60) / 60); if(this.life % 5 === 0) { const angle = Math.atan2(this.target.y-this.owner.y, this.target.x - this.owner.x); const dist = Math.hypot(this.target.x - this.owner.x, this.target.y - this.owner.y); for(let i=0; i < dist; i+= player.size) {const x = this.owner.x+Math.cos(angle)*i; const y=this.owner.y+Math.sin(angle)*i; if(isColliding({x:x-player.size/2, y:y-player.size/2, size:player.size},{x:player.x,y:player.y,size:player.size})) { player.takeDamage(this.owner.damage/10); break;}}}} draw() {ctx.save(); const angle = Math.atan2(this.target.y - this.owner.y, this.target.x-this.owner.x); ctx.translate(this.owner.x+this.owner.size/2, this.owner.y+this.owner.size/2); ctx.rotate(angle); ctx.globalAlpha = 0.6; ctx.fillStyle='#9b59b6'; ctx.fillRect(0, -this.width/2, 1200, this.width); ctx.restore();}}
        class SlimeTrail { constructor(x, y, size) { this.x=x;this.y=y;this.size=size;this.life=180; } update(){this.life--; if(this.life<0)this.isDead=true; if(!player.isDead && isColliding(this, player)) {player.takeDamage(0.1);}} draw() {ctx.globalAlpha=this.life/180 * 0.5; ctx.fillStyle = '#228b22'; ctx.beginPath(); ctx.arc(this.x+this.size/2, this.y+this.size/2, this.size/2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1;}}
        class ExplosionEffect { constructor(x, y, radius, damage) { this.x=x; this.y=y; this.radius = radius; this.damage = damage; this.life=20; this.maxRadius = radius; [player, ...minions].forEach(t => { if(isColliding(this,t)) t.takeDamage(this.damage); }); } update(){ this.life--; if(this.life<0)this.isDead=true; this.radius = this.maxRadius * (this.life/20); } draw() { ctx.save(); ctx.globalAlpha = this.life/20; ctx.fillStyle='#e67e22'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill(); ctx.restore(); }}

        function getCurrentBiome() { const biomeIndex = Math.floor((currentRoom - 1) / 7) % biomes.length; return biomes[biomeIndex]; }
        function setupNewRoomEnvironment() { const biome = getCurrentBiome(); document.body.style.backgroundColor = biome.bodyColor; canvas.style.backgroundColor = biome.bgColor; obstacles = []; if(currentRoom % 7 === 0) return; const obstacleCount = Math.floor(canvas.width * canvas.height / 30000 * biome.obstacleDensity); for(let i=0; i<obstacleCount; i++) { const w = 50 + Math.random()*100; const h = 50 + Math.random()*100; const x = Math.random()*(canvas.width - w); const y = Math.random()*(canvas.height - h-150); if(!obstacles.some(ob => Math.hypot(ob.x-x, ob.y-y) < 200)) obstacles.push(new Obstacle(x,y,w,h, biome.obstacleColor)); } }
        function startRoom() { gameState = 'playing'; projectiles = []; corpses = []; portal = null; boss = null; ui.bossUi.style.display = 'none'; player.x = canvas.width / 2 - player.size / 2; player.y = canvas.height - player.size - 20; minions.forEach(m => { m.x = player.x + (Math.random()-0.5)*50; m.y = canvas.height + 40 + Math.random()*20; }); isBossRoom = currentRoom > 0 && currentRoom % 7 === 0; setupNewRoomEnvironment(); if (isBossRoom) { enemies = []; const bossChoices = [LichKingBoss, FleshAmalgamBoss, EyeOfChaosBoss]; const BossToSpawn = bossChoices[Math.floor(Math.random()*bossChoices.length)]; boss = new BossToSpawn(canvas.width/2-40, 100, currentRoom); ui.bossUi.style.display = 'block'; } else { enemies = []; const enemyCount = 4 + Math.floor(currentRoom / 2); let enemyPool = ['melee']; if(currentRoom > 2) enemyPool.push('ranged'); if(currentRoom > 5) enemyPool.push('cultist'); if(currentRoom > 8) enemyPool.push('brute'); if(currentRoom > 10) enemyPool.push('shadowmancer'); for (let i = 0; i < enemyCount; i++) { let validPos = false; let x,y; let attempts=0; while(!validPos && attempts < 50) { x = Math.random() * (canvas.width - 40); y = Math.random() * (canvas.height / 2); validPos = !obstacles.some(ob => isColliding({x,y,size:30}, {x:ob.x, y:ob.y, w:ob.w, h:ob.h})); attempts++;} const type = enemyPool[Math.floor(Math.random() * enemyPool.length)]; switch(type) { case 'ranged': enemies.push(new RangedEnemy(x,y,currentRoom)); break; case 'brute': enemies.push(new BruteEnemy(x,y,currentRoom)); break; case 'cultist': enemies.push(new CultistEnemy(x,y,currentRoom)); break; case 'shadowmancer': enemies.push(new ShadowmancerEnemy(x,y,currentRoom)); break; default: enemies.push(new MeleeEnemy(x,y,currentRoom)); break; } } } }
        function handleObstacleCollision(unit) { obstacles.forEach(ob => { if (unit instanceof WraithMinion && unit.dashCooldown > unit.dashRate-30) return; const dx = (unit.x + unit.size/2) - (ob.x + ob.w/2); const dy = (unit.y + unit.size/2) - (ob.y + ob.h/2); const halfW = (unit.size + ob.w)/2; const halfH = (unit.size+ob.h)/2; if(Math.abs(dx) < halfW && Math.abs(dy) < halfH) { const oX = halfW - Math.abs(dx); const oY = halfH - Math.abs(dy); if(oX < oY) { unit.x += dx > 0 ? oX : -oX; } else { unit.y += dy > 0 ? oY : -oY; } } }); }
        function checkCollisions() { for (let i = projectiles.length-1; i>=0; i--) { const p = projectiles[i]; if(p.isDead) continue; let hitObstacle = obstacles.some(ob => isColliding({x:p.x-p.radius, y:p.y-p.radius, size:p.radius*2}, ob)); if(hitObstacle) {p.isDead=true; continue;} const targets = enemies.concat(boss ? [boss]:[]); if(p.owner === 'player' || p.owner === 'minion') { for(const e of targets) { if(!e.isDead && isColliding(p,e)) { e.takeDamage(p.damage, p.isCrit); if(p.isCrit) screenShake=10; if(p.onHitEffect) p.onHitEffect(e); p.isDead=true; break; } } } else if(p.owner === 'enemy') { if(!player.isDead && isColliding(p,player)) {player.takeDamage(p.damage); p.isDead=true; continue;} for(const m of minions) {if(!m.isDead && isColliding(p,m)){m.takeDamage(p.damage);p.isDead=true;break;}}}} const damagePerFrame = 1 / 60; const allTargets = [player, ...minions]; enemies.concat(boss ? [boss] : []).forEach(e => { if (e.isDead || !e.target || !(e instanceof MeleeEnemy) || e instanceof FleshAmalgamBoss) return; for(const t of allTargets) { if(!t.isDead && isColliding(e, t)) t.takeDamage(e.damage * damagePerFrame); } }); minions.forEach(m => {if (!m.isDead && m.target && !(m instanceof RangedMinion)) if(isColliding(m, m.target)) {m.target.takeDamage(m.damage * damagePerFrame); } }); if(portal && isColliding(player, portal)) { gameState="cardSelection"; offerCardSelection(); } for (let i = essenceOrbs.length - 1; i >= 0; i--) { const orb = essenceOrbs[i]; if(isColliding(player, {x: orb.x - orb.size/2, y: orb.y - orb.size/2, size: orb.size})) { player.gainXP(orb.xpValue); player.health = Math.min(player.maxHealth, player.health + player.essenceHeal); essenceOrbs.splice(i,1); } } }
        cleanup = function() { enemies.forEach(e => { if (e.isDead && !e.corpseMade) { if(e.type!=='shade') {corpses.push(new Corpse(e.x, e.y, e.size, e.type)); essenceOrbs.push(new EssenceOrb(e.x + e.size/2, e.y + e.size/2, e.baseXp)); combo++; comboTimer = 180; } e.corpseMade = true; } }); if (boss && boss.isDead && !boss.corpseMade) { lastBossDefeatedName = boss.bossName; essenceOrbs.push(new EssenceOrb(boss.x + boss.size/2, boss.y+boss.size/2, boss.baseXp)); metaProgress.ectoplasma += 500; boss.corpseMade=true; } enemies = enemies.filter(e => !e.isDead); minions = minions.filter(m => !m.isDead); projectiles = projectiles.filter(p => !p.isDead && p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height); floatingTexts = floatingTexts.filter(ft => ft.duration > 0); specialEffects = specialEffects.filter(se => se.life > 0 || !se.isDead); }
        defineCards = function(){ cardPool=[{title:"Vigor Sombrio",description:"Aumenta sua vida máxima em 25 e cura a mesma quantidade.",apply:()=>{player.maxHealth+=25;player.health=Math.min(player.maxHealth,player.health+25)}},{title:"Pacto de Sangue",description:"Projéteis do Necromante causam +10 de dano.",apply:()=>{player.projectileDamage+=10}},{title:"Horda Reforçada",description:"Lacaios ganham +30% de vida e dano.",apply:()=>{player.minionPower+=.3;minions.forEach(m=>{m.maxHealth*=1.3;m.health*=1.3;m.damage*=1.3})}},{title:"Senhor dos Mortos",description:"Aumenta o limite de lacaios em +2.",apply:()=>{player.maxMinions+=2;updateMinionFormations()}},{title:"Salva Coordenada",description:"Lacaios atiradores disparam 25% mais rápido.",apply:()=>{minions.forEach(m=>{if(m instanceof RangedMinion)m.shootRate*=.75})}},{title:"Ressurreição em Massa",description:"Revive 2 lacaios de corpos disponíveis.",apply:()=>{for(let e=0;e<2&&corpses.length>0&&minions.length<player.maxMinions;e++){const corpse=corpses.pop();player.createMinionFromCorpse(corpse,0);}}}, {title:"Precisão Letal", description:"Aumenta sua chance de acerto crítico em 5% (para esta partida).", apply:()=>{player.critChance+=0.05}}, {title:"Sifão de Almas", description:"Orbes de essência curam +3 de vida adicional (para esta partida).", apply:()=>{player.essenceHeal+=3}} ];}
        offerCardSelection = function(){ gameState="cardSelection"; ui.cardScreen.style.display="flex";ui.cardOptions.innerHTML="";const e=[...cardPool];const cardCount = isBossRoom ? 4 : 3; for(let t=0;t<cardCount;t++){if(0===e.length)break;const o=Math.floor(Math.random()*e.length),n=e.splice(o,1)[0],a=document.createElement("div");a.className="card";a.innerHTML=`<h3>${n.title}</h3><p>${n.description}</p>`;a.onclick=()=>selectCard(n);ui.cardOptions.appendChild(a)}}
        selectCard = function(cardData){cardData.apply();ui.cardScreen.style.display="none";currentRoom++;startRoom()}
        isColliding = function(rect1, rect2){ const r1x = rect1.radius ? rect1.x - rect1.radius : rect1.x; const r1y = rect1.radius ? rect1.y - rect1.radius : rect1.y; const r1w = rect1.radius ? rect1.radius * 2 : (rect1.w || rect1.size); const r1h = rect1.radius ? rect1.radius * 2 : (rect1.h || rect1.size); const r2x = rect2.x; const r2y = rect2.y; const r2w = rect2.w || rect2.size; const r2h = rect2.h || rect2.size; return r1x < r2x + r2w && r1x + r1w > r2x && r1y < r2y + r2h && r1y + r1h > r2y;}
        handleSeparation = function(){const allUnits = [player, ...minions, ...enemies];if(boss)allUnits.push(boss); for (let i = 0; i < allUnits.length; i++) { handleObstacleCollision(allUnits[i]); for (let j = i + 1; j < allUnits.length; j++) { const unitA = allUnits[i], unitB = allUnits[j]; if (unitA.isDead || unitB.isDead) continue; const dx = unitB.x - unitA.x, dy = unitB.y - unitA.y; const dist = Math.hypot(dx, dy); const minDist = (unitA.size / 2) + (unitB.size / 2); if (dist < minDist) { const overlap = minDist - dist, angle = Math.atan2(dy, dx); unitA.x -= Math.cos(angle) * overlap / 2; unitA.y -= Math.sin(angle) * overlap / 2; unitB.x += Math.cos(angle) * overlap / 2; unitB.y += Math.sin(angle) * overlap / 2; unitA.clampToBounds(); unitB.clampToBounds(); } } } }
        updateMinionFormations = function(){const e=60+2*player.maxMinions;minions.forEach((t,o)=>{const n=o*Math.PI*2/Math.max(1, minions.length);t.formationOffset.x=Math.cos(n)*e;t.formationOffset.y=Math.sin(n)*e})}
        
        // --- GAME STATE & LOOP ---
        function init() { gameState = 'start'; screenShake = 0; loadGameData(); ui.startScreen.style.display = 'flex'; ui.gameOverScreen.style.display = 'none'; ui.cardScreen.style.display = 'none'; ui.tomeScreen.style.display = 'none'; setupMobileControls(); resizeCanvas(); window.addEventListener('resize', resizeCanvas); }
        function resizeCanvas() { const { innerWidth, innerHeight } = window; canvas.width = innerWidth; canvas.height = innerHeight; }
        function startGame() { resizeCanvas(); currentRoom = 1; combo = 1; comboTimer = 0; defineCards(); player = new Player(canvas.width / 2 - 15, canvas.height / 2 - 15); minions = []; essenceOrbs = []; floatingTexts = []; specialEffects = []; obstacles=[]; startRoom(); ui.startScreen.style.display = 'none'; ui.gameOverScreen.style.display = 'none'; ui.tomeScreen.style.display = 'none'; if(gameState !== 'playing') gameLoop(); }
        function handleGameOver() { const ectoplasmaGained = (currentRoom -1) * 50 + (player.level - 1) * 20; metaProgress.ectoplasma += ectoplasmaGained; saveGameData(); ui.finalScore.textContent = `Você chegou até a sala ${currentRoom}.`; ui.lastBossDefeated.textContent = `Último chefe derrotado: ${lastBossDefeatedName}`; ui.ectoplasmaEarned.textContent = `Ectoplasma Coletado: ${ectoplasmaGained}`; ui.gameOverScreen.style.display = 'flex'; }
        function gameLoop() { update(); draw(); if (gameState !== 'gameOver') requestAnimationFrame(gameLoop); }
        function update() { if (screenShake > 0) screenShake--; if (gameState !== 'playing') return; if (comboTimer > 0) { comboTimer--; } else { combo = 1; } const updateList = [player, ...projectiles, ...enemies, ...minions, ...essenceOrbs, ...floatingTexts, ...specialEffects]; if(boss) updateList.push(boss); updateList.forEach(e => e.update()); handleSeparation(); checkCollisions(); cleanup(); if (enemies.length === 0 && !portal && (!boss || boss.isDead)) { portal = new Portal(canvas.width / 2, 100); if(!isBossRoom) metaProgress.ectoplasma += currentRoom * 10; } if (portal) portal.update(); }
        function draw() { ctx.save(); ctx.clearRect(0, 0, canvas.width, canvas.height); if(screenShake > 0) { const shakeX = (Math.random() - 0.5) * screenShake * 0.5; const shakeY = (Math.random() - 0.5) * screenShake * 0.5; ctx.translate(shakeX, shakeY); } if (gameState === 'playing' || gameState === 'cardSelection') { obstacles.forEach(o => o.draw()); corpses.forEach(c => c.draw()); essenceOrbs.forEach(o => o.draw()); if (portal) portal.draw(); specialEffects.forEach(e => e.draw()); const drawList = [...enemies, ...minions, player, ...projectiles]; if(boss) drawList.push(boss); drawList.sort((a,b) => (a.y+a.size) - (b.y+b.size)).forEach(e => e.draw()); floatingTexts.forEach(ft => ft.draw()); ui.health.style.width = `${(player.health / player.maxHealth) * 100}%`; const xpPercent = (player.xp / player.xpToNextLevel) * 100; ui.xpFill.style.width = `${xpPercent}%`; ui.xpBar.classList.toggle('pulsing', xpPercent > 85); ui.room.textContent = `${getCurrentBiome().name} - ${currentRoom}`; ui.minions.textContent = `Lacaios: ${minions.length}/${player.maxMinions}`; ui.enemyCounter.textContent = `Inimigos: ${enemies.length}`; if(boss) { ui.bossHealth.style.width = `${(boss.health / boss.maxHealth) * 100}%`; ui.enemyCounter.textContent = ''; } if (combo > 1) { const comboColor = combo < 5 ? '#ffffff' : (combo < 10 ? '#f1c40f' : '#e74c3c'); ui.comboMeter.textContent = `COMBO x${combo}`; ui.comboMeter.style.color = comboColor; ui.comboMeter.style.textShadow = `0 0 8px ${comboColor}`; } else { ui.comboMeter.textContent = ''; } } ctx.restore(); }
        
        // --- META PROGRESS ---
        const permanentUpgrades = { baseHealth: { name: "Vigor Eterno", desc: "Aumenta a vida inicial em 10.", cost: 100, scale: 1.6 }, baseDamage: { name: "Poder Arcano", desc: "Aumenta o dano inicial dos projéteis em 3.", cost: 150, scale: 1.8 }, minionPower: { name: "Suserano", desc: "Aumenta a força inicial dos lacaios em 10%.", cost: 200, scale: 2.0 }, critChance: { name: "Olho da Morte", desc: "Aumenta a chance de crítico inicial em 2%.", cost: 300, scale: 2.2 }, essenceHeal: { name: "Sifão Vital", desc: "Aumenta a cura dos orbes em 1.", cost: 120, scale: 1.5 } };
        function populateTomeScreen() { ui.tomeEctoplasmaTotal.textContent = `Ectoplasma Total: ${metaProgress.ectoplasma}`; ui.tomeUpgradesContainer.innerHTML = ''; for (const key in permanentUpgrades) { const upgrade = permanentUpgrades[key]; const currentLevel = metaProgress.upgrades[key] || 0; const cost = Math.floor(upgrade.cost * Math.pow(upgrade.scale, currentLevel)); const item = document.createElement('div'); item.className = 'upgrade-item'; item.innerHTML = ` <div class="upgrade-info"> <h4>${upgrade.name} (Nível ${currentLevel})</h4> <p>${upgrade.desc}</p> </div> <button id="buy-${key}" ${metaProgress.ectoplasma < cost ? 'disabled' : ''}>Comprar (${cost})</button> `; ui.tomeUpgradesContainer.appendChild(item); document.getElementById(`buy-${key}`).addEventListener('click', () => buyUpgrade(key)); } }
        function buyUpgrade(key) { const upgrade = permanentUpgrades[key]; const currentLevel = metaProgress.upgrades[key] || 0; const cost = Math.floor(upgrade.cost * Math.pow(upgrade.scale, currentLevel)); if (metaProgress.ectoplasma >= cost) { metaProgress.ectoplasma -= cost; metaProgress.upgrades[key] = (metaProgress.upgrades[key] || 0) + 1; saveGameData(); populateTomeScreen(); } }

        // --- MOBILE CONTROLS SETUP ---
        function setupMobileControls() {
            function setupJoystick(baseEl, stickEl, controlObject) {
                const maxDist = baseEl.offsetWidth / 2;
                let touchId = null;
                baseEl.addEventListener('touchstart', e => { e.preventDefault(); if (touchId === null) { touchId = e.changedTouches[0].identifier; } }, { passive: false });
                baseEl.addEventListener('touchmove', e => { e.preventDefault(); for(let touch of e.changedTouches) { if(touch.identifier === touchId) { const rect = baseEl.getBoundingClientRect(); let dx = touch.clientX - (rect.left + rect.width / 2); let dy = touch.clientY - (rect.top + rect.height / 2); const dist = Math.hypot(dx, dy); let finalDx = dx / dist; let finalDy = dy / dist; if (dist > maxDist) { dx = finalDx * maxDist; dy = finalDy * maxDist; } stickEl.style.transform = `translate(${dx}px, ${dy}px)`; controlObject.x = finalDx; controlObject.y = finalDy; controlObject.active = true; break; } } }, { passive: false });
                const endTouch = e => { for(let touch of e.changedTouches) { if(touch.identifier === touchId) { stickEl.style.transform = `translate(0px, 0px)`; controlObject.active = false; touchId = null; break; } } };
                baseEl.addEventListener('touchend', endTouch); baseEl.addEventListener('touchcancel', endTouch);
            }
            setupJoystick(getUI('move-joystick-base'), getUI('move-joystick-stick'), controls.move);
            setupJoystick(getUI('aim-joystick-base'), getUI('aim-joystick-stick'), controls.aim);
            getUI('revive-button').addEventListener('touchstart', e => { e.preventDefault(); controls.revive = true; });
        }
        
        ui.startButton.addEventListener('click', startGame);
        ui.restartButton.addEventListener('click', startGame);
        ui.tomeButton.addEventListener('click', () => { ui.gameOverScreen.style.display = 'none'; ui.tomeScreen.style.display = 'flex'; populateTomeScreen(); });
        ui.closeTomeButton.addEventListener('click', () => { ui.tomeScreen.style.display = 'none'; ui.startScreen.style.display = 'flex'; });

        init();
    });
    </script>
</body>
</html>
