<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Necromancer Roguelike - Responsive & Final</title>
    <style>
        body { margin: 0; background-color: #1a1a1a; color: #e0e0e0; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Courier New', Courier, monospace; overflow: hidden; }
        #game-container { position: relative; border: 2px solid #5a3d7a; box-shadow: 0 0 20px rgba(120, 50, 220, 0.5); }
        canvas { display: block; background-color: #0d0d0d; cursor: crosshair; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; padding: 10px; box-sizing: border-box; text-shadow: 2px 2px 4px #000; }
        .top-ui { display: flex; justify-content: space-between; align-items: center; font-size: 18px; }
        #player-health-bar { width: 200px; height: 20px; background-color: #444; border: 1px solid #777; }
        #player-health { width: 100%; height: 100%; background-color: #b30000; transition: width 0.2s; }
        .screen-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; }
        h1, p, button { font-family: 'Courier New', Courier, monospace; }
        h1 { font-size: 3em; color: #8e44ad; text-shadow: 0 0 10px #8e44ad; }
        p { font-size: 1.2em; margin: 10px; }
        button { padding: 15px 30px; font-size: 1.5em; background-color: #8e44ad; color: white; border: 2px solid #c07df7; cursor: pointer; border-radius: 5px; }
        #card-selection-screen { pointer-events: all; }
        #card-options { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 20px; }
        .card { width: 180px; height: 250px; background-color: #2c3e50; border: 3px solid #7f8c8d; border-radius: 10px; padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center; cursor: pointer; }
        .card h3 { color: #e67e22; margin-top: 0; font-size: 1.2em; }
        .card p { font-size: 0.9em; flex-grow: 1; }

        /* --- CONTROLES MOBILE --- */
        #mobile-controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; display: none; pointer-events: none; z-index: 20; }
        body.mobile-active #mobile-controls { display: block; }
        .joystick-zone, .action-zone { position: absolute; bottom: 20px; width: 50%; height: 200px; }
        .joystick-zone { left: 0; }
        .action-zone { right: 0; display: flex; justify-content: space-around; align-items: center; }
        .joystick-base { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 120px; height: 120px; background-color: rgba(255, 255, 255, 0.2); border-radius: 50%; pointer-events: all; }
        .joystick-stick { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background-color: rgba(255, 255, 255, 0.4); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        .action-button { width: 80px; height: 80px; background-color: rgba(142, 68, 173, 0.5); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; pointer-events: all; display: flex; justify-content: center; align-items: center; color: white; font-size: 12px; text-align: center; }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="game-container">
        <!-- O canvas agora não tem tamanho fixo -->
        <canvas id="gameCanvas"></canvas>
        <div id="ui-overlay">
            <div class="top-ui">
                <div><span>VIDA:</span><div id="player-health-bar"><div id="player-health"></div></div></div>
                <div id="enemy-counter">INIMIGOS: 0</div>
                <div id="minion-counter">LACAIOS: 0/5</div>
                <div id="room-counter">SALA: 1</div>
            </div>
        </div>
        <div id="mobile-controls">
            <div class="joystick-zone">
                <div id="joystick-base" class="joystick-base"><div id="joystick-stick" class="joystick-stick"></div></div>
            </div>
            <div class="action-zone">
                <div id="revive-button" class="action-button">REVIVER</div>
                <div id="attack-button" class="action-button">ATACAR</div>
            </div>
        </div>
        <div id="start-screen" class="screen-overlay">
            <h1>Necromancer's Rise</h1>
            <p>Inimigos têm formas e ataques únicos. Aprenda a combatê-los!</p>
            <p>Use W, A, S, D ou o joystick para se mover.</p>
            <button id="start-button">Iniciar Jogo</button>
        </div>
        <div id="game-over-screen" class="screen-overlay" style="display: none;"><h1 id="game-over-title">Fim de Jogo</h1><p id="final-score"></p><button id="restart-button">Tentar Novamente</button></div>
        <div id="card-selection-screen" class="screen-overlay" style="display: none;"><h1>Escolha um Aprimoramento</h1><p>Seu poder cresce a cada sala conquistada.</p><div id="card-options"></div></div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ui = {};
        const getUI = id => document.getElementById(id);
        Object.assign(ui, { health: getUI('player-health'), room: getUI('room-counter'), minions: getUI('minion-counter'), enemyCounter: getUI('enemy-counter'), startScreen: getUI('start-screen'), gameOverScreen: getUI('game-over-screen'), cardScreen: getUI('card-selection-screen'), cardOptions: getUI('card-options'), startButton: getUI('start-button'), restartButton: getUI('restart-button'), finalScore: getUI('final-score'), });
        
        let gameState, currentRoom, player, enemies, projectiles, corpses, minions, portal, keys, mouse, cardPool;
        keys = {}; mouse = { x: 0, y: 0, left: false, right: false };
        let mobileAimDirection = { x: 0, y: -1 };

        // --- LÓGICA DE RESPONSIVIDADE ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas, false);

        // --- CLASSES E LÓGICA DO JOGO ---
        class Entity {
            constructor(x, y, size, color) { this.x = x; this.y = y; this.size = size; this.color = color; this.isDead = false; }
            draw() { if (this.isDead) return; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); }
            update() {}
            clampToBounds() { this.x = Math.max(0, Math.min(canvas.width - this.size, this.x)); this.y = Math.max(0, Math.min(canvas.height - this.size, this.y)); }
        }
        class Battler extends Entity {
            constructor(x, y, size, color, health, speed, damage) { super(x, y, size, color); this.maxHealth = health; this.health = health; this.speed = speed; this.damage = damage; this.target = null; }
            takeDamage(amount) { if (this.isDead) return; this.health -= amount; if (this.health <= 0) { this.health = 0; this.isDead = true; } }
            drawHealthBar() { if (this.isDead) return; ctx.fillStyle = '#c0392b'; ctx.fillRect(this.x, this.y - 10, this.size, 5); ctx.fillStyle = '#27ae60'; ctx.fillRect(this.x, this.y - 10, this.size * (this.health / this.maxHealth), 5); }
            findTarget(potentialTargets) { let closestDist = this.aggroRadius || Infinity; this.target = null; for (const t of potentialTargets) { if (t.isDead) continue; const dist = Math.hypot(this.x - t.x, this.y - t.y); if (dist < closestDist) { closestDist = dist; this.target = t; } } }
            move(newX, newY) { this.x = newX; this.y = newY; this.clampToBounds(); }
            moveToTarget() { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); this.move(this.x + Math.cos(angle) * this.speed, this.y + Math.sin(angle) * this.speed); }
            moveFromTarget() { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); this.move(this.x - Math.cos(angle) * this.speed, this.y - Math.sin(angle) * this.speed); }
        }
        class Projectile extends Entity { constructor(x, y, radius, color, speed, angle, damage) { super(x, y, radius * 2, color); this.radius = radius; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.damage = damage; } update() { this.x += this.vx; this.y += this.vy; } draw() { if(this.isDead) return; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill(); } }
        class Player extends Battler {
            constructor(x, y) { super(x, y, 30, '#8e44ad', 100, 5, 0); this.maxMinions = 5; this.minionPower = 1.0; this.projectileDamage = 25; this.shootCooldown = 0; this.reviveCooldown = 0; }
            takeDamage(amount) { if (this.isDead) return; this.health -= amount; if (this.health <= 0) { this.health = 0; this.isDead = true; gameState = 'gameOver'; } }
            draw() { if(this.isDead) return; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); this.drawHealthBar(); }
            update() {
                const moveX = (keys['d'] ? 1 : 0) - (keys['a'] ? 1 : 0); const moveY = (keys['s'] ? 1 : 0) - (keys['w'] ? 1 : 0);
                if (moveX !== 0 || moveY !== 0) { mobileAimDirection = { x: moveX, y: moveY }; }
                this.move(this.x + moveX * this.speed, this.y + moveY * this.speed);
                if (this.shootCooldown > 0) this.shootCooldown--; if (this.reviveCooldown > 0) this.reviveCooldown--;
                if (mouse.left && this.shootCooldown === 0) { const isMobile = document.body.classList.contains('mobile-active'); const angle = isMobile ? Math.atan2(mobileAimDirection.y, mobileAimDirection.x) : Math.atan2(mouse.y - (this.y + this.size / 2), mouse.x - (this.x + this.size / 2)); projectiles.push(new PlayerProjectile(this.x + this.size / 2, this.y + this.size / 2, angle, this.projectileDamage)); this.shootCooldown = 15; }
                if (mouse.right && this.reviveCooldown === 0 && minions.length < this.maxMinions) { if (document.body.classList.contains('mobile-active')) this.reviveClosestCorpse(); else this.reviveAtMouse(); }
            }
            reviveAtMouse() { for (let i = corpses.length - 1; i >= 0; i--) { const corpse = corpses[i]; if (Math.hypot(mouse.x - (corpse.x + corpse.size / 2), mouse.y - (corpse.y + corpse.size / 2)) < corpse.size) { this.createMinionFromCorpse(corpse, i); break; } } }
            reviveClosestCorpse() { let closestCorpse = null; let minDist = 150; for(const corpse of corpses) { const dist = Math.hypot(this.x - corpse.x, this.y - corpse.y); if(dist < minDist) { minDist = dist; closestCorpse = corpse; } } if(closestCorpse) { this.createMinionFromCorpse(closestCorpse, corpses.indexOf(closestCorpse)); } }
            createMinionFromCorpse(corpse, index) { if (corpse.type === 'ranged') minions.push(new RangedMinion(corpse.x, corpse.y)); else minions.push(new MeleeMinion(corpse.x, corpse.y, corpse.type)); corpses.splice(index, 1); this.reviveCooldown = 30; updateMinionFormations(); }
        }
        class MeleeMinion extends Battler { constructor(x, y, revivedType) { const h = revivedType === 'brute' ? 1.5 : 1.0, d = revivedType === 'brute' ? 1.2 : 1.0; super(x, y, 20, '#2ecc71', (50 * player.minionPower) * h, 3.5, (10 * player.minionPower) * d); this.aggroRadius = 350; this.formationOffset = { x: 0, y: 0 }; } draw() { if(this.isDead) return; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); this.drawHealthBar(); } update() { this.findTarget(enemies); if (this.target) this.moveToTarget(); else this.returnToFormation(); } returnToFormation() { const targetX = player.x + this.formationOffset.x, targetY = player.y + this.formationOffset.y; if (Math.hypot(targetX - this.x, targetY - this.y) > 5) { const angle = Math.atan2(targetY - this.y, targetX - this.x); this.move(this.x + Math.cos(angle) * this.speed, this.y + Math.sin(angle) * this.speed); } } }
        class RangedMinion extends Battler { constructor(x, y) { super(x, y, 20, '#1abc9c', 40 * player.minionPower, 3, 8 * player.minionPower); this.aggroRadius = 450; this.optimalDistance = 250; this.shootCooldown = 0; this.shootRate = 90; this.formationOffset = { x: 0, y: 0 }; } draw() { if(this.isDead) return; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); this.drawHealthBar(); } update() { if(this.shootCooldown > 0) this.shootCooldown--; this.findTarget(enemies); if (this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if (dist > this.optimalDistance) this.moveToTarget(); else if (dist < this.optimalDistance - 50) this.moveFromTarget(); else if (this.shootCooldown === 0) { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); projectiles.push(new MinionProjectile(this.x + this.size/2, this.y + this.size/2, angle, this.damage)); this.shootCooldown = this.shootRate; } } else this.returnToFormation(); } returnToFormation() { const targetX = player.x + this.formationOffset.x, targetY = player.y + this.formationOffset.y; if (Math.hypot(targetX - this.x, targetY - this.y) > 5) { const angle = Math.atan2(targetY - this.y, targetX - this.x); this.move(this.x + Math.cos(angle) * this.speed, this.y + Math.sin(angle) * this.speed); } } }
        class MeleeEnemy extends Battler { constructor(x, y, room) { super(x, y, 25, '#e74c3c', 20 + room * 15, 1 + room * 0.15, 5 + room * 2); this.type = 'melee'; this.lungeCooldown = 180; this.lungeDuration = 0; this.baseSpeed = this.speed; } draw() { if(this.isDead) return; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); this.drawHealthBar(); } update() { this.findTarget([player, ...minions]); if (this.lungeCooldown > 0) this.lungeCooldown--; if (this.lungeDuration > 0) { this.lungeDuration--; if(this.lungeDuration === 0) this.speed = this.baseSpeed; } if(this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if(dist < 150 && this.lungeCooldown === 0) { this.speed = this.baseSpeed * 3; this.lungeDuration = 30; this.lungeCooldown = 240; } this.moveToTarget(); } } }
        class RangedEnemy extends Battler { constructor(x, y, room) { super(x, y, 28, '#3498db', 15 + room * 10, 0.8 + room * 0.1, 8 + room * 2); this.type = 'ranged'; this.optimalDistance = 300; this.shootCooldown = Math.random() * 120; this.shootRate = 180; this.isBursting = false; this.burstCount = 0; } draw() { if (this.isDead) return; let angle = this.target ? Math.atan2(this.target.y - this.y, this.target.x - this.x) : 0; ctx.save(); ctx.translate(this.x + this.size / 2, this.y + this.size / 2); ctx.rotate(angle); ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(this.size / 2, 0); ctx.lineTo(-this.size / 2, -this.size / 3); ctx.lineTo(-this.size / 2, this.size / 3); ctx.closePath(); ctx.fill(); ctx.restore(); this.drawHealthBar(); } update() { if (this.isBursting) { this.shootCooldown--; if(this.shootCooldown <= 0 && this.burstCount > 0){ const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); projectiles.push(new EnemyProjectile(this.x+this.size/2, this.y+this.size/2, angle, this.damage)); this.burstCount--; this.shootCooldown = 10; } if(this.burstCount === 0) { this.isBursting = false; this.shootCooldown = this.shootRate; } return; } if(this.shootCooldown > 0) this.shootCooldown--; this.findTarget([player, ...minions]); if(this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if(dist > this.optimalDistance + 50) this.moveToTarget(); else if (dist < this.optimalDistance) this.moveFromTarget(); else if(this.shootCooldown === 0) { this.isBursting = true; this.burstCount = 3; this.shootCooldown = 0; } } } }
        class BruteEnemy extends Battler { constructor(x, y, room) { super(x, y, 40, '#6c7a89', 80 + room * 25, 0.7 + room * 0.05, 10 + room * 3); this.type = 'brute'; this.stompRadius = 80; this.stompCooldown = 300; this.stompCharge = 0; } draw() { if (this.isDead) return; ctx.beginPath(); ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2); ctx.fillStyle = this.stompCharge > 0 ? '#f1c40f' : this.color; ctx.fill(); if(this.stompCharge > 0) { ctx.strokeStyle = 'rgba(241, 196, 15, 0.5)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.size/2, this.y + this.size/2, this.stompRadius, 0, Math.PI * 2); ctx.stroke(); } this.drawHealthBar(); } update() { if (this.stompCooldown > 0 && this.stompCharge === 0) this.stompCooldown--; if (this.stompCharge > 0) { this.stompCharge--; if (this.stompCharge === 0) { this.stompCooldown = 300; } return; } this.findTarget([player, ...minions]); if(this.target) { const dist = Math.hypot(this.x - this.target.x, this.y - this.target.y); if(dist < this.size && this.stompCooldown === 0) { this.stompCharge = 60; } else { this.moveToTarget(); } } } }
        class PlayerProjectile extends Projectile { constructor(x, y, angle, damage) { super(x, y, 5, '#9b59b6', 8, angle, damage); this.owner = 'player'; } }
        class EnemyProjectile extends Projectile { constructor(x, y, angle, damage) { super(x, y, 6, '#f39c12', 6, angle, damage); this.owner = 'enemy'; } }
        class MinionProjectile extends Projectile { constructor(x, y, angle, damage) { super(x, y, 4, '#ecf0f1', 7, angle, damage); this.owner = 'minion'; } }
        class Corpse { constructor(x,y,size,type) { this.x = x; this.y = y; this.size = size; this.type = type; this.color = '#7f8c8d'; } draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size / 2, 0, Math.PI * 2); ctx.fill(); } }
        class Portal { constructor(x,y) { this.x = x; this.y = y; this.size = 50; this.color = '#3498db'; this.angle = 0; } update() { this.angle += 0.02; } draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = this.color; ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); ctx.strokeStyle = '#ecf0f1'; ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size); ctx.restore(); } }

        function startRoom(roomNumber) { gameState = 'playing'; projectiles = []; corpses = []; portal = null; player.x = canvas.width / 2 - player.size / 2; player.y = canvas.height - player.size - 20; enemies = []; const enemyCount = 4 + roomNumber * 2; let enemyPool = ['melee']; if (roomNumber >= 2) enemyPool.push('melee', 'ranged'); if (roomNumber >= 4) enemyPool.push('brute'); if (roomNumber >= 5) enemyPool.push('ranged'); for (let i = 0; i < enemyCount; i++) { const x = Math.random() * (canvas.width - 40); const y = Math.random() * (canvas.height / 2); const type = enemyPool[Math.floor(Math.random() * enemyPool.length)]; if (type === 'ranged') enemies.push(new RangedEnemy(x, y, roomNumber)); else if (type === 'brute') enemies.push(new BruteEnemy(x, y, roomNumber)); else enemies.push(new MeleeEnemy(x, y, roomNumber)); } }
        function checkCollisions() { for (const p of projectiles) { if (p.isDead) continue; if (p.owner === 'player' || p.owner === 'minion') { for (const e of enemies) { if (e.isDead) continue; if (isColliding(p, e)) { e.takeDamage(p.damage); p.isDead = true; break; } } } else if (p.owner === 'enemy') { if (!player.isDead && isColliding(p, player)) { player.takeDamage(p.damage); p.isDead = true; continue; } for (const m of minions) { if (m.isDead) continue; if (isColliding(p, m)) { m.takeDamage(p.damage); p.isDead = true; break; } } } } const damagePerFrame = 1 / 60; for (const e of enemies) { if (e.isDead || !e.target) continue; if (e instanceof MeleeEnemy && isColliding(e, e.target)) e.target.takeDamage(e.damage * damagePerFrame); if (e instanceof BruteEnemy) { if(e.stompCharge === 1){ [player, ...minions].forEach(unit => { if(!unit.isDead && Math.hypot(e.x - unit.x, e.y - unit.y) < e.stompRadius) unit.takeDamage(e.damage * 2); }); } } } for (const m of minions) { if (m.isDead || !m.target || m instanceof RangedMinion) continue; if (isColliding(m, m.target)) m.target.takeDamage(m.damage * damagePerFrame); } if(portal && isColliding(player, portal)) offerCardSelection(); }
        function cleanup() { enemies.forEach(e => { if (e.isDead && !e.corpseMade) { corpses.push(new Corpse(e.x, e.y, e.size, e.type)); e.corpseMade = true; } }); enemies = enemies.filter(e => !e.isDead); minions = minions.filter(m => !m.isDead); projectiles = projectiles.filter(p => !p.isDead && p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height); }
        function defineCards(){cardPool=[{title:"Vigor Sombrio",description:"Aumenta sua vida máxima em 25 e cura a mesma quantidade.",apply:()=>{player.maxHealth+=25;player.health=Math.min(player.maxHealth,player.health+25)}},{title:"Pacto de Sangue",description:"Projéteis do Necromante causam +10 de dano.",apply:()=>{player.projectileDamage+=10}},{title:"Horda Reforçada",description:"Lacaios ganham +30% de vida e dano.",apply:()=>{player.minionPower+=.3;minions.forEach(m=>{m.maxHealth*=1.3;m.health*=1.3;m.damage*=1.3})}},{title:"Senhor dos Mortos",description:"Aumenta o limite de lacaios em +2.",apply:()=>{player.maxMinions+=2;updateMinionFormations()}},{title:"Salva Coordenada",description:"Lacaios atiradores disparam 25% mais rápido.",apply:()=>{minions.forEach(m=>{if(m instanceof RangedMinion)m.shootRate*=.75})}},{title:"Ressurreição em Massa",description:"Revive 2 lacaios de corpos disponíveis.",apply:()=>{for(let e=0;e<2;e++)corpses.length>0&&minions.length<player.maxMinions&&(corpse=corpses.pop(),corpse.type==="ranged"?minions.push(new RangedMinion(corpse.x,corpse.y)):minions.push(new MeleeMinion(corpse.x,corpse.y,corpse.type)));updateMinionFormations()}}]}
        function offerCardSelection(){gameState="cardSelection";ui.cardScreen.style.display="flex";ui.cardOptions.innerHTML="";const e=[...cardPool];for(let t=0;t<3;t++){if(0===e.length)break;const o=Math.floor(Math.random()*e.length),n=e.splice(o,1)[0],a=document.createElement("div");a.className="card";a.innerHTML=`<h3>${n.title}</h3><p>${n.description}</p>`;a.onclick=()=>selectCard(n);ui.cardOptions.appendChild(a)}}
        function selectCard(cardData){cardData.apply();ui.cardScreen.style.display="none";currentRoom++;startRoom(currentRoom)}
        function isColliding(rect1, rect2){const size1=rect1.radius?rect1.radius*2:rect1.size,size2=rect2.size,x1=rect1.radius?rect1.x-rect1.radius:rect1.x,y1=rect1.radius?rect1.y-rect1.radius:rect1.y;return x1<rect2.x+size2&&x1+size1>rect2.x&&y1<rect2.y+size2&&y1+size1>rect2.y}
        function handleSeparation(){const allUnits = [player, ...minions];for (let i = 0; i < allUnits.length; i++) { for (let j = i + 1; j < allUnits.length; j++) { const unitA = allUnits[i], unitB = allUnits[j]; if (unitA.isDead || unitB.isDead) continue; const dx = unitB.x - unitA.x, dy = unitB.y - unitA.y; const dist = Math.hypot(dx, dy); const minDist = (unitA.size / 2) + (unitB.size / 2); if (dist < minDist) { const overlap = minDist - dist, angle = Math.atan2(dy, dx); unitA.x -= Math.cos(angle) * overlap / 2; unitA.y -= Math.sin(angle) * overlap / 2; unitB.x += Math.cos(angle) * overlap / 2; unitB.y += Math.sin(angle) * overlap / 2; unitA.clampToBounds(); unitB.clampToBounds(); } } } }
        function updateMinionFormations(){const e=60+2*player.maxMinions;minions.forEach((t,o)=>{const n=o*Math.PI*2/Math.max(minions.length,player.maxMinions);t.formationOffset.x=Math.cos(n)*e;t.formationOffset.y=Math.sin(n)*e})}
        
        function init() { resizeCanvas(); gameState = 'start'; ui.startScreen.style.display = 'flex'; ui.gameOverScreen.style.display = 'none'; ui.cardScreen.style.display = 'none'; setupControls(); }
        function startGame() { currentRoom = 1; defineCards(); player = new Player(canvas.width / 2 - 15, canvas.height / 2 - 15); minions = []; startRoom(currentRoom); gameLoop(); }
        function gameLoop() { update(); draw(); if (gameState !== 'gameOver') requestAnimationFrame(gameLoop); }
        function update() { if (gameState !== 'playing') return; [player, ...projectiles, ...enemies, ...minions].forEach(e => e.update()); handleSeparation(); checkCollisions(); cleanup(); if (enemies.length === 0 && !portal) { portal = new Portal(canvas.width / 2, 100); } if (portal) portal.update(); }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (gameState === 'playing' || gameState === 'cardSelection') {
                corpses.forEach(c => c.draw()); if (portal) portal.draw();
                [...enemies, ...minions, player, ...projectiles].forEach(e => e.draw());
                ui.health.style.width = `${(player.health / player.maxHealth) * 100}%`;
                ui.room.textContent = `SALA: ${currentRoom}`;
                ui.minions.textContent = `LACAIOS: ${minions.length} / ${player.maxMinions}`;
                ui.enemyCounter.textContent = `INIMIGOS: ${enemies.length}`;
            } else if (gameState === 'gameOver') {
                ui.finalScore.textContent = `Você chegou até a sala ${currentRoom}.`; ui.gameOverScreen.style.display = 'flex';
            }
        }
        
        function setupControls() {
            if ('ontouchstart' in window) { document.body.classList.add('mobile-active'); setupMobileControls(); } else { setupDesktopControls(); }
        }
        function setupDesktopControls() { window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true); window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false); canvas.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; }); canvas.addEventListener('mousedown', (e) => { if (e.button === 0) mouse.left = true; if (e.button === 2) mouse.right = true; }); canvas.addEventListener('mouseup', (e) => { if (e.button === 0) mouse.left = false; if (e.button === 2) mouse.right = false; }); }
        function setupMobileControls() {
            const joystickBase = document.getElementById('joystick-base'); const joystickStick = document.getElementById('joystick-stick');
            const attackButton = document.getElementById('attack-button'); const reviveButton = document.getElementById('revive-button');
            const maxJoyDist = joystickBase.offsetWidth / 2;
            function handleTouch(e) { e.preventDefault(); const rect = joystickBase.getBoundingClientRect(); const touch = e.targetTouches[0]; let dx = touch.clientX - (rect.left + rect.width / 2); let dy = touch.clientY - (rect.top + rect.height / 2); const dist = Math.hypot(dx, dy); if (dist > maxJoyDist) { dx = (dx / dist) * maxJoyDist; dy = (dy / dist) * maxJoyDist; } joystickStick.style.transform = `translate(${dx - 30}px, ${dy - 30}px)`; const deadZone = 0.2; keys['w'] = (dy / maxJoyDist < -deadZone); keys['s'] = (dy / maxJoyDist > deadZone); keys['a'] = (dx / maxJoyDist < -deadZone); keys['d'] = (dx / maxJoyDist > deadZone); }
            function handleTouchEnd(e) { e.preventDefault(); joystickStick.style.transform = `translate(-50%, -50%)`; keys['w'] = keys['a'] = keys['s'] = keys['d'] = false; }
            joystickBase.addEventListener('touchstart', handleTouch, { passive: false }); joystickBase.addEventListener('touchmove', handleTouch, { passive: false }); joystickBase.addEventListener('touchend', handleTouchEnd, { passive: false });
            attackButton.addEventListener('touchstart', (e) => { e.preventDefault(); mouse.left = true; }); attackButton.addEventListener('touchend', (e) => { e.preventDefault(); mouse.left = false; });
            reviveButton.addEventListener('touchstart', (e) => { e.preventDefault(); mouse.right = true; }); reviveButton.addEventListener('touchend', (e) => { e.preventDefault(); mouse.right = false; });
        }
        
        ui.startButton.addEventListener('click', () => { ui.startScreen.style.display = 'none'; startGame(); });
        ui.restartButton.addEventListener('click', () => { ui.gameOverScreen.style.display = 'none'; startGame(); });
        
        init();
    });
    </script>
</body>
</html>
